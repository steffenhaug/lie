(function id x. x)

(function curry fun arg1. λ arg. apply fun arg1 arg)

(function compose f g. λ x. (f (g x)))

(function not a. if a then False else True)

(function incr n. + n 1)

(function decr n. - n 1)

(define zero? (curry = 0))

(define one? (curry = 1))

(define positive? (curry > 0))

(define negative? (curry < 0))

(function max x y. if (< x y) then y else x)

(function min x y. if (< x y) then x else y)

(function odd? x. one? (mod x 2))

(function even? x. zero? (mod x 2))

(function square x. * x x)

(function flip f. λ x y. f y x)

(function cons x xs. conj [x] xs)

(function append x xs. conj xs [x])

(function empty? vec. = [] vec)

(function singleton? vec. one? (length vec))

(function foldl fun acc vec.
  let v  <- (head vec).
      vs <- (tail vec).
  in if (empty? vec) then acc
     else (foldl fun (fun acc v) vs))

(function foldr fun end vec.
  let v  <- (head vec).
      vs <- (tail vec).
  in if (empty? vec) then end
     else (fun v (foldr fun end vs)))	

(function unfold fun init pred.
  if (pred init) then [init]
  else (cons init (unfold fun (fun init) pred)))

(function repeat a n.
  if (zero? n) then []
  else (cons a (repeat a (- n 1))))

(function reduce fun vec.
  let v  <- (head vec).
      vs <- (tail vec).
  in foldl fun v vs)

(function map fun vec.
  let Γ <- (λ x xs. cons (fun x) xs).
  in foldr Γ [] vec)

(function mapfilter fun pred vec.
  let v  <- (head vec).
      vs <- (tail vec).
      Γ  <- (λ x xs. let x' <- (fun x).
	       	     in if (pred x') then (cons x' xs)
		     	else xs).
  in foldr Γ [] vec)

(function mapreduce mfun rfun vec.
  let v  <- (mfun (head vec)).
      vs <- (tail vec).
      Γ  <- (λ x y. rfun x (mfun y)).
  in foldl Γ v vs)

(function filter pred vec.
  let Γ <- (λ x xs. if (pred x) then (cons x xs) else xs).
  in foldr Γ [] vec)

(define all (curry reduce and))

(define any (curry reduce or))

(define sup (curry reduce max))

(define inf (curry reduce min))

(define sum (curry reduce +))

(function slice start stop vec.
  let length <- (- stop start).
  in get start length vec)

(function take n vec. get 0 n vec) 

(function drop n vec. slice n (length vec) vec)

(function last vec. get (- (length vec) 1) vec)

(define Σ sum)

(define product (curry reduce *))

(define Π product)

(function reverse vec. foldr append [] vec)
